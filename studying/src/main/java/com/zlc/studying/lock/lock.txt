来源: https://www.cnblogs.com/jyroy/p/11365935.html
通过特性将锁分类如下:
1、线程要不要锁住同步资源?
    1.1、锁住: 悲观锁 适合写操作多的情况, 先加锁保证写操作时正确;
    1.2、不锁: 乐观锁 适合读操作多的情况, 提高读的性能;  CAS算法实现(compare and swap)
        CAS三大问题: ABA问题
                  : 循环时间长开销大, 长时间循环会给CPU带来巨大压力
                  : 只能保证一个共享变量的原子操作, 多个共享变量时不能保证
2、锁住同步资源失败, 线程要不要阻塞?
    2.1、阻塞
    2.2、不阻塞: 自旋可以避免线程切换(适合同步同步资源锁定时间短的情况),但是会占用CPU资源,所以自旋等待限定一定次数(-XX:preBlockSpin)设置,
                获取失败挂起, 1.4中使用-XX:+UseSpinning开启, 1.6中默认开启, 并加入了适应性自旋锁
        2.2.1、自旋
        2.2.2、适应性自旋 : 自旋次数不固定, 由前一次在同一个锁上的自旋时间和锁的拥有者状态来决定..
3、多个线程竞争同步资源的流程细节有没有区别?
    3.1、无锁: 不锁住资源, 多个线程只有一个能修改成功, 其他会重试
    3.2、偏向锁: 同一个线程执行同步资源时会自动获取资源
    3.3、轻量级锁: 多个线程竞争资源时, 没有获得资源的线程自旋等待锁释放
    3.4、重量级锁: 多个线程竞争资源时, 没有获得资源的线程阻塞等待被唤醒
    这四种是指锁的状态, 专门针对synchronized的;synchronized是如何实现线程同步的? Java对象头、Monitor; synchronized是将锁加在对象头上的
        Java对象头:
            HotSpot中对象头包含两部分数据: Mark Word(标记字段)、Klass Pointer(类型指针)
            Mark Word: 存储对象的HashCode、分代年龄、锁标志位信息;
            Klass Pointer: 对象指向它的类元数据指针, 虚拟机通过这个来确定对象是哪个类的实例;
        Monitor:
            可以理解为一个同步工具或一种同步机制, 通常被描述为一个对象; 每个java对象都有一把看不加的锁,称为内部锁或者Monitor锁
            Monitor是线程私有的数据结构,每个线程都有一个可用Monitor Record列表, 同时还有一个全局的可用列表; 每个被锁住的对象都会和一个
            monitor关联, 同时Monitor中有一个Owner字段存放拥有该锁的线程的唯一标志, 表示该锁被这个线程占用
    synchronized是通过Monitor来实现线程同步, Monitor是依赖于底层的操作系统的Mutex Lock(互斥锁)来实现的线程同步
    四种锁状态下对应的Mark Word内容:
        锁状态                Mark Word存储内容                               存储内容
        无锁     :     对象HashCode、对象分代年龄、是否为偏向锁(0)                  01
        偏向锁    :    偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁(1)          01
        轻量级锁  :    指向栈中锁记录的指针                                        00
        重量级锁  :    指向互斥量(重量级锁)的指针                                   10


4、多个线程竞争锁时要不要排队?
    4.1、公平锁: 排队
    4.2、非公平锁: 先尝试插队, 插队失败时排队
5、一个线程中的多个流程能不能获取同一把锁?
    5.1、能: 可重入锁(又名递归锁)
    5.2、不能: 非可重入锁
6、多个线程能不能共享一把锁?
    6.1、能: 共享锁
    6.2、不能: 排它锁

