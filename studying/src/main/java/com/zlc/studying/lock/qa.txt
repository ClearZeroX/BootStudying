1、synchronized作用于静态方法和非静态方法的区别
    非静态方法：
        给对象加锁(可以理解为给这个对象的内存上锁,注意 只是这块内存,其他同类对象都会有各自的内存锁),这时候在其他一个以上线程中执行该对象
        的这个同步方法(注意:是该对象)就会产生互斥
    静态方法: 相当于在类上加锁(*.class
        位于代码区,静态方法位于静态区域,这个类产生的对象公用这个静态方法,所以这块内存，N个对象来竞争),这时候,只要是这个类产生的对象,
        在调用这个静态方法时都会产生互斥。即该类所有的对象都共享一把锁。

2、一个线程进入一个对象的synchronized方法A后, 另一个线程可否进入这个对象的Synchronized方法B?
    不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，
    如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁
        注: 所有java对象都有锁(monitor)池和等待池两个池;
        锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，
            由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了
            该对象的锁池中。
        等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，
            这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象
            的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同
            对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.
        深入理解:
            如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的
            notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，
            锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，
            唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，
            它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。
3、线程同步的几种方式?
    1)、synchronized
    2)、volatile修饰(可以保证可见性, 但是不能保证原子性)
    3)、使用局部变量ThreadLocal(空间换时间, 提供副本)
    4)、使用原子类(AtomicInteger、AtomicBoolean...)
    5)、使用Lock
    6)、使用容器类(BlockingQueue、ConcurrentHashMap...)
4、synchronized和java.util.concurrent.locks.Lock有何异同?
    1) synchronized的锁会由JVM自动释放, Lock的锁需要手动释放!!!
    2)
5、乐观锁与悲观锁的理解以及如何实现? 有哪些实现方式?

6、synchronized有哪些缺点?

7、我们面对ReentrantLock和synchronized改如何选择？
    Synchronized相比Lock，为许多开发人员所熟悉，并且简洁紧凑，如果现有程序已经使用了内置锁，那么尽量保持代码风格统一，尽量不引入Lock，
    避免两种机制混用，容易令人困惑，也容易发生错误。在Synchronized无法满足需求的情况下，Lock可以作为一种高级工具，这些功能包括"可定时的、
    可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁"否则还是优先使用Synchronized。最后，未来更可能提升Synchronized而不是Lock的性能，
    因为Synchronized是JVM的内置属性，他能执行一些优化，例如对线程封闭的锁对象的锁消除优化，通过增加锁的粒度来消除内置锁的同步，而如果基于
    类库的锁来实现这些功能，则可能性不大

8、死锁产生的四个条件?
    互斥条件: 资源时独占的且排他使用
    不可剥夺条件: 获得的资源在未使用完毕前, 不能被其他线程剥夺, 只能由获得该资源的线程释放
    请求和保持条件: 进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
    循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，
    形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源

