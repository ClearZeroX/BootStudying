1、synchronized作用于静态方法和非静态方法的区别
    非静态方法：
        给对象加锁(可以理解为给这个对象的内存上锁,注意 只是这块内存,其他同类对象都会有各自的内存锁),这时候在其他一个以上线程中执行该对象
        的这个同步方法(注意:是该对象)就会产生互斥
    静态方法: 相当于在类上加锁(*.class
        位于代码区,静态方法位于静态区域,这个类产生的对象公用这个静态方法,所以这块内存，N个对象来竞争),这时候,只要是这个类产生的对象,
        在调用这个静态方法时都会产生互斥。即该类所有的对象都共享一把锁。

2、一个线程进入一个对象的synchronized方法A后, 另一个线程可否进入这个对象的Synchronized方法B?
    不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，
    如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁
        注: 所有java对象都有锁(monitor)池和等待池两个池;
        锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，
            由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了
            该对象的锁池中。
        等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，
            这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象
            的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同
            对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.
        深入理解:
            如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的
            notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，
            锁池中的线程会去竞争该对象锁。优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，
            唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，
            它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。
3、线程同步的几种方式?
    1)、synchronized
    2)、volatile修饰(可以保证可见性, 但是不能保证原子性)
    3)、使用局部变量ThreadLocal(空间换时间, 提供副本)
    4)、使用原子类(AtomicInteger、AtomicBoolean...)
    5)、使用Lock
    6)、使用容器类(BlockingQueue、ConcurrentHashMap...)

