# 线程生命周期及5种基本状态
![](https://cdn.jsdelivr.net/gh/ClearZeroX/image/images/2020/Thread.png)

1. 新建(new) 
    > Thread t = new Thread() 新创建了一个线程对象
2. 就绪(runnable) 
    > start() 线程对象被创建后, 当调用先成的start()方法后, 处于就绪状态, 等待被线程调度选中, 获取CPU的使用权
3. 运行(running)
    > 就绪状态的线程获得了cpu时间片(timeSlice),执行程序代码. 注: **就绪状态是进入运行状态的唯一入口**.
4. 阻塞(blocked)
    > 处于运行状态中的线程由于某种原因, 暂时放弃对CPU的使用权, 停止执行, 此时进入到阻塞状态, 直到其进入到就绪状态, 
                  才有机会再次进行到运行状态  
    > 1. 等待阻塞: 运行状态中的线程执行wait()方法, JVM会把线程放入到等待队列(waiting queue)中,进入到等待阻塞状态; notifyAll()调用后, 
                  会将全部线程由等待池移到锁池, 然后参与锁的竞争, 竞争成功则仅需执行, 如果不成功则留在锁池等待锁被释放后再次参与竞争
    > 2. 同步阻塞: 线程在获取synchronized同步锁失败(因为锁被其他线程所占用), 则JVM会把线程放入锁池(lock pool)中, 线程进入同步阻塞状态
    > 3. 其他阻塞: 通过调用线程的sleep()或join()或发出了I/O请求时, 线程会进入到阻塞状态. 当sleep()状态超时, join()等待线程终止或者超时
                  或者i/O处理完毕时, 线程重新转入就绪状态.
5. 销毁(dead)
    > 线程run()、main()方法执行结束, 或者因一场退出了run()方法, 则该线程结束生命周期, 死亡的线程不可再次复生